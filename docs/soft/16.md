## 说明

16进制以 0x 开头的字符，例如：0xff、0x11

平时不是比较常用的表达形式，但是它有一个很好的优势，就是简短容易记，比如下标列出了部分 **比较特殊** 的 16 进制和 2 进制的对应关系。


| 16进制  | 2进制  | 说明  |
| --- | --- | --- |
| 0xff  | 1111 1111 | 每一个 f 代表 一个 1111 |
| 0x0f0f | 0000 1111 0000 1111  | 0000 和 1111 交替出现 |
| 0xf0f0 | 1111 0000 1111 0000  | 1111 和 0000 交替出现 |
| 0x5555 | 0101 0101 0101 0101 | 每一个 5 代表一个 0101，（偶数位是 0，奇数位是 1） |
| 0xaaaa | 1010 1010 1010 1010 | 每一个 a 代表一个 1010，（偶数位是 1，基数位是 0） |
| 0x3333 | 0011 0011 0011 0011 | 每一个 3 代表一个 0011 |
| 0xcccc | 1100 1100 1100 1100 | 每一个 c 代表一个 1100 |

好了，知道了上述这些特殊的 16 进制数字有什么用呢？其实最主要的就是为了 ① 好记，② 好写，③ 易读：

1. 好记，比如 0xff，就很容易记忆
2. 好写，比如 0x55，就代表 0101 0101，不用再写一堆 0 1 了
3. 易读，比如 0x55555555 代表 0101 0101 0101 0101 0101 0101 0101 0101，此处的**易读**是相对的，因为前提是对16进制有了深入的理解之后

## 应用

#### 场景 A

比如在处理图片时需要获取指定像素的 RGB 值，就可以用到上述的 16 进制。

因为像素的其中一种数据存储格式是用4个 byte 来表示的，按顺序分别为：alpha 值、R 值、G 值、B 值。

所以，获取 RGB 值其实就是截取这个 2 进制数的过程。如下：

1. R 值：(pixel & 0xff0000) >> 16 
2. G 值：(pixel & 0xff00) >> 8
3. B 值：(pixel & 0xff)

上面的 0xff0000 其实就是 1111 1111 0000 0000 0000 0000，与像素进行与运算，则顺利取出来了 R 值。

#### 场景  B
  
比如 leetcode 题库中有一道简单题： 判断一个整数是否是4的幂次方

对于这一题，判断一个整数是否是 4 的幂次方，其实我们只需要知道 4 的幂次方，这类数据的 2 进制形式，其实有两个特点：① 除了高位是1 以外，其余位均是 0，② 1 后面 0 的个数是偶数个，所以我们只需要根据这两个特点来判断即可，即满足上述两个条件即可（当然，这个数需要大于 0）：

① (num & (num - 1)) == 0  
② (num & 0x55555555) == num

说明：举例 num = 64  ，二进制为：0100 0000  
① 0100 0000 & 0011 1111，结果为 0  
② 0100 0000 & 0101 0101 0101 0101 0101 0101 0101 0101，结果其实就是 num 本身，因为 4 的幂次方的特点 2 说明了 1 后面 0 的数量是 偶数个，则 1 必然出现在奇数位置上面，而 0x5 正好是 0101，即只有奇数位是 1 